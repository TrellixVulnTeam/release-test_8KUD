"use strict";

exports.__esModule = true;
exports.uploadStats = uploadStats;

var _zlib = _interopRequireDefault(require("zlib"));

var _util = require("util");

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _axios = _interopRequireDefault(require("axios"));

var _gzipSize = _interopRequireDefault(require("gzip-size"));

var _brotliSize = _interopRequireDefault(require("brotli-size"));

var _omitDeep = _interopRequireDefault(require("omit-deep"));

var _provider = require("./provider");

var _config = require("./config");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const gzip = (0, _util.promisify)(_zlib.default.gzip);

async function sizeAssets(webpackStats, {
  fileSystem = _fs.default
} = {}) {
  const readFile = (0, _util.promisify)(fileSystem.readFile ? fileSystem.readFile.bind(fileSystem) : _fs.default.readFile);
  return Promise.all(webpackStats.assets.map(async asset => {
    const fullPath = _path.default.join(webpackStats.outputPath, asset.name);

    const buffer = await readFile(fullPath);
    return _extends({}, asset, {
      gzipSize: await (0, _gzipSize.default)(buffer),
      brotliSize: _brotliSize.default.sync(buffer)
    });
  }));
}

function getErrorMessage(error) {
  if (error.response && error.response.data && error.response.data.error && error.response.data.error.message) {
    return error.response.data.error.message;
  }

  return error.message;
}

async function uploadStats({
  context = process.cwd(),
  configFile,
  webpackStats,
  token: optionToken,
  fileSystem
}) {
  try {
    const token = (0, _config.getToken)(optionToken);
    const apiUrl = (0, _config.getApiUrl)();
    const metadata = (0, _provider.detectProvider)();
    const stats = (0, _omitDeep.default)(webpackStats, 'source');
    const config = await (0, _config.resolveConfig)(context, configFile);
    const assets = await sizeAssets(stats, {
      fileSystem
    });
    const {
      data: bundle
    } = await _axios.default.post(`${apiUrl}/bundles`, {
      token,
      bundler: 'webpack',
      stats: {
        assets,
        chunksNumber: stats.chunks.length,
        modulesNumber: stats.modules.length,
        assetsNumber: stats.assets.length
      }
    });
    const data = await gzip(Buffer.from(JSON.stringify(stats)));
    await _axios.default.request({
      method: 'put',
      url: bundle.webpackStatsPutUrl,
      data,
      headers: {
        'content-encoding': 'gzip'
      },
      maxContentLength: 30 * 1024 * 1024
    });
    await _axios.default.post(`${apiUrl}/builds`, {
      token,
      bundleId: bundle.id,
      branch: metadata.branch,
      commit: metadata.commit,
      providerMetadata: metadata,
      config
    });
  } catch (error) {
    if (error.response && error.response.data && error.response.data.error && error.response.data.error.errors) {
      console.error('Invalid Bundle Analyzer config:');
      error.response.data.error.errors.forEach(message => console.error(message));
    }

    throw new Error(getErrorMessage(error));
  }
}